options {
  STATIC = false;
  LOOKAHEAD = 2;
  FORCE_LA_CHECK = true;
  CHOICE_AMBIGUITY_CHECK = 2;
  OTHER_AMBIGUITY_CHECK = 1;
  DEBUG_PARSER = false;
  DEBUG_LOOKAHEAD = false;
  DEBUG_TOKEN_MANAGER = false;
  ERROR_REPORTING = true;
  JAVA_UNICODE_ESCAPE = false;
  UNICODE_INPUT = true;
  USER_TOKEN_MANAGER = false;
  USER_CHAR_STREAM = false;
  BUILD_PARSER = true;
  BUILD_TOKEN_MANAGER = true;
  SANITY_CHECK = true;
  KEEP_LINE_COLUMN = false;
  VISITOR = true;
  MULTI = true;
}

PARSER_BEGIN(FilterParser)
/**
 * [Phillip Watson] ("COMPANY") CONFIDENTIAL Unpublished Copyright Â© 2019-2020 Phillip Watson,
 * All Rights Reserved.
 *
 * NOTICE: All information contained herein is, and remains the property of COMPANY. The
 * intellectual and technical concepts contained herein are proprietary to COMPANY and may be
 * covered by U.K. and Foreign Patents, patents in process, and are protected by trade secret or
 * copyright law. Dissemination of this information or reproduction of this material is strictly
 * forbidden unless prior written permission is obtained from COMPANY. Access to the source code
 * contained herein is hereby forbidden to anyone except current COMPANY employees, managers or
 * contractors who have executed Confidentiality and Non-disclosure agreements explicitly covering
 * such access.
 *
 * The copyright notice above does not evidence any actual or intended publication or disclosure of
 * this source code, which includes information that is confidential and/or proprietary, and is a
 * trade secret, of COMPANY. ANY REPRODUCTION, MODIFICATION, DISTRIBUTION, PUBLIC PERFORMANCE, OR
 * PUBLIC DISPLAY OF OR THROUGH USE OF THIS SOURCE CODE WITHOUT THE EXPRESS WRITTEN CONSENT OF
 * COMPANY IS STRICTLY PROHIBITED, AND IN VIOLATION OF APPLICABLE LAWS AND INTERNATIONAL TREATIES.
 * THE RECEIPT OR POSSESSION OF THIS SOURCE CODE AND/OR RELATED INFORMATION DOES NOT CONVEY OR IMPLY
 * ANY RIGHTS TO REPRODUCE, DISCLOSE OR DISTRIBUTE ITS CONTENTS, OR TO MANUFACTURE, USE, OR SELL
 * ANYTHING THAT IT MAY DESCRIBE, IN WHOLE OR IN PART.
 */
package com.hillayes.query.filter.parser;

import java.io.StringReader;

import com.hillayes.query.filter.exceptions.InvalidComparisonException;
import com.hillayes.query.filter.expression.*;
import com.hillayes.query.filter.function.*;

/**
 * The starting point for parsing a query filter. This should not be instantiated
 * but, rather, the static method {@link #parse(String)} should be
 * used to perform the parsing.
 *
 * @author <a href="mailto:watson.phill@gmail.com">Phill Watson</a>
 * @since 1.0.0
 */
public class FilterParser
{
    /**
     * This is the preferred method of parsing a query filter. It will parse the
     * given filter expression and create a node tree that represents the elements
     * of that filter expression.
     * <p>
     * The hierarchy of the nodes in the generated node tree represents the order
     * of precedence of the expressions within the filter; with the lower order
     * nodes appearing first. For example; the operator OR has a lower order then
     * the AND operator so, in the expression "a eq 2 and b gt 3 or c lt 4" the
     * tree hierarchy would be:
     * <pre>
     *  Or
     *    And
     *      Comparison (a eq 2) 
     *      Comparison (b gt 3)
     *    Comparison (c lt 4)
     * </pre>
     * When the nodes are evaluated from the bottom-up the AND comparisons will
     * be evaluated before first, with the result of that comparison feeding in
     * to the OR comparisons. 
     * <p>
     * See the JUnit code for more example of how expression are parsed.
     * <p>
     * These nodes can, and should, be traversed using an instance of the interface
     * {@link FilterParserVisitor}. Perhaps the most important method of this
     * interface is {@link FilterParserVisitor#visit(ASTComparison, Object)}.
     * The given ASTComparison object holds an instance of Expression
     * that fully describes the comparison; the named property, function (if
     * any), the operator (if any) and the value (if any). From this the
     * implementation should be able to construct the equivalent comparison in
     * whatever target notation it requires (e.g. SQL or JPA).
     * 
     * @param aFilter the REST URL query filter expression to be parsed.
     * @return the root node of the parsed filter expression.
     */
    public static Node parse(String aFilter) throws ParseException, TokenMgrError, InvalidComparisonException
    {
        if ((aFilter != null) && (aFilter.length() > 0)) {
            FilterParser parser = new FilterParser(new StringReader(aFilter));
            return parser.parse();
        }

        return(null);
    }
}
PARSER_END(FilterParser)

/**  And now, the actual parsing specifications...... */

/** Skip these characters, they are considered "white space" **/
SKIP : { " " | "\t" | "\r" | "\n" | "\f" }

TOKEN[IGNORE_CASE]: /* RESERVED TOKENS - case-insensitive */
{
      <AND: "and" >
    | <OR:  "or" >
    | <NOT: "not" >
    | <EQ: "eq" >
    | <NE: "ne" >
    | <GT: "gt" >
    | <LT: "lt" >
    | <GE: "ge" >
    | <LE: "le" >
    | <LPAREN: "(" >
    | <RPAREN: ")" >
    | <COMMA: "," >
}

TOKEN: /* RESERVED TOKENS - case-sensitive */
{
      <TOUPPER: "upper" >
    | <TOLOWER: "lower" >
    | <CONTAINS: "contains" >
    | <ENDSWITH: "endswith" >
    | <STARTSWITH: "startswith" >
    | <NOTNULL: "notnull" >
    | <ISNULL: "isnull" >
}

TOKEN: /* LITERALS */
{
      <#DIGIT: ["0" - "9"] >
    | <#ALPHA: ["A"-"Z" , "a"-"z", "_", "$"] >
    | <#INTEGER: ( <DIGIT> )+ >
    | <DOT: "." >
    | <NUMERIC: (["+","-"])? ( <INTEGER> | ( <INTEGER> <DOT> <INTEGER> ) ) >
    | <QUOTED_TEXT: ( "\"" ( ~["\""] )* "\"" ) | ( "'" ( ~["'"] )* "'" ) >
    | <IDENTIFIER: <ALPHA> (<ALPHA> | <DIGIT> | <DOT> | "-")* > 
}

/**
 * The start of the parsing process. This will simply apply the "orExpression"
 * lexical analysis. The order in which the subsequent methods are called will
 * determine the order of precedence given to the AND, OR and NOT operators,
 * and how brackets can be used to override that precedence order.
 */
Node parse() throws InvalidComparisonException : { }
{
    orExpression() <EOF>
    { return jjtThis; }
}

/**
 * Looks for a sequence of "andExpression" nodes and, if more than one, will
 * combine them under an "or" node.
 */
void orExpression() throws InvalidComparisonException #void : { }
{
    // return either a single expression node
    // or multiple expression nodes enclosed in an OR node 
    (
      andExpression()
      (
        <OR>
        andExpression()
      )*
    ) #Or(>1)
}

/**
 * Looks for a sequence of "expression" nodes and, if more than one, will
 * combine them under an "and" node.
 */
void andExpression() throws InvalidComparisonException #void : { }
{
    // return either a single expression node
    // or multiple expression nodes enclosed in an AND node 
    (
      expression()
      (
        <AND>
        expression()
      )*
    ) #And(>1)
}

/**
 * Looks for a comparison expression or a NOT comparison expression or a
 * sequence of expression contained within brackets.
 */
void expression() throws InvalidComparisonException #void : { }
{
    // return either a comparison node
    // or a comparison node enclosed in a NOT node
    // or the start of a new expression enclosed in brackets
    Comparison()

    | (
        <NOT>
        orExpression() #Not
      )

    | (
        <LPAREN>
        orExpression() #LParen
        <RPAREN>
      )
}

/**
 * The start of a comparison. This create a new Expression, and then populate
 * that Expression by passing it to the subsequent parsing methods.
 */
void Comparison() throws InvalidComparisonException: { Expression expression = new Expression(); }
{
    // look for a null function, boolean function or a comparison expression
    (
        NullFunction(expression)
      | BiFunction(expression)
      | Expression(expression)
    )

    {
      // record the Expression in the resulting ASTComparison node
      jjtThis.jjtSetValue(expression);
    }
}

/**
 * Looks for one of the possible boolean functions and populates the given
 * Expression with the name of the function and the name of the property
 * to be passed to the function. The format is expected to be:
 *
 *    function(property)
 */
void NullFunction(Expression aExpression) #void : { }
{
    { FunctionArgument function = null; }

    (
      // look for one of the known functions and record its name
        <ISNULL>  { function = new FunctionArgument(BoolFunction.ISNULL); }
      | <NOTNULL> { function = new FunctionArgument(BoolFunction.NOTNULL); }
    )

    <LPAREN>
    // look for a property name parameter to the function
    <IDENTIFIER> { function.addArgument(new PropertyArgument(getToken(0).image)); }
    <RPAREN>

    {
        aExpression.setLeftArg(function);
    }
}

/**
 * Looks for one of the possible bi-arg functions and populates the given
 * Expression with the name of the function, the name of the property
 * and the value to be passed to the function. The format is expected to be:
 *
 *    function(property, value)
 */
void BiFunction(Expression aExpression) #void : { }
{
    { FunctionArgument function = null; }

    (
      // look for one of the known functions and record its name
        <CONTAINS>   { function = new FunctionArgument(BiFunction.CONTAINS); }
      | <ENDSWITH>   { function = new FunctionArgument(BiFunction.ENDSWITH); }
      | <STARTSWITH> { function = new FunctionArgument(BiFunction.STARTSWITH); }
    )

    <LPAREN>
    // look for a property name parameter to the function
    <IDENTIFIER> { function.addArgument(new PropertyArgument(getToken(0).image)); }
    <COMMA>
    // look for the value parameter to the function
    <QUOTED_TEXT> { function.addArgument(new StringArgument(getToken(0).image)); }
    <RPAREN>

    {
        aExpression.setLeftArg(function);
    }
}

/**
 * Looks for a comparison, with a possible function applied to the named
 * property. It will populate the given Expression with attributes
 * of the comparison (function name, property name, operator and value).
 * The format is expected to be:
 *
 *    function(property) operator value
 * or
 *    property operator value
 */
void Expression(Expression aExpression) #void : { }
{
    (
      // look for either a function OR a property name and record the info
        UnaryFunction(aExpression)
      | <IDENTIFIER> { aExpression.setLeftArg(new PropertyArgument(getToken(0).image)); }
    )

    (
      // record the operator to be applied
        <EQ> { aExpression.setOperator(Operator.EQ); }
      | <NE> { aExpression.setOperator(Operator.NE); }
      | <GT> { aExpression.setOperator(Operator.GT); }
      | <LT> { aExpression.setOperator(Operator.LT); }
      | <GE> { aExpression.setOperator(Operator.GE); }
      | <LE> { aExpression.setOperator(Operator.LE); }
    )

    (
      // look for either a property, quoted string or number
        <IDENTIFIER>  { aExpression.setRightArg(new PropertyArgument(getToken(0).image)); }
      | <QUOTED_TEXT> { aExpression.setRightArg(new StringArgument(getToken(0).image)); }
      | <NUMERIC>     { aExpression.setRightArg(new NumericArgument(getToken(0).image)); }
    )
}

/**
 * Looks for one of the possible functions that take a single named property
 * as a parameter, and populates the given Expression with the name of
 * that function and the name of the property or a string constant. The format
 * is expected to be:
 *
 *    function(property)
 */
void UnaryFunction(Expression aExpression) #void : { }
{
    { FunctionArgument function = null; }

    (
        <TOLOWER> { function = new FunctionArgument(UnaryFunction.LOWER); }
      | <TOUPPER> { function = new FunctionArgument(UnaryFunction.UPPER); }
    )

    <LPAREN>
    <IDENTIFIER> { function.addArgument(new PropertyArgument(getToken(0).image)); }
    <RPAREN>

    {
        aExpression.setLeftArg(function);
    }
}
